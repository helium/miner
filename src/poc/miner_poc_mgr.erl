%%%-------------------------------------------------------------------
%%% @doc
%%% listens for block events, inspects the POCs in the block metadata
%%% and for each of our own keys which made it into the block
%%% kick off a POC
%%% @end
%%%-------------------------------------------------------------------
-module(miner_poc_mgr).

-behaviour(gen_server).

-include_lib("blockchain/include/blockchain_vars.hrl").
-include_lib("blockchain/include/blockchain.hrl").
-include_lib("public_key/include/public_key.hrl").
-include_lib("blockchain/include/blockchain_utils.hrl").

-define(ADDR_HASH_FP_RATE, 1.0e-9).
-define(LOCAL_POC_DB_CF, {?MODULE, local_poc_db_cf_handle}).
-define(LOCAL_POC_KEYS_DB_CF, {?MODULE, local_poc_keys_db_cf_handle}).
-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
%% lifespan of a POC, after which we will
%% submit the receipts txn and delete the local poc data
-define(POC_TIMEOUT, 4).
-else.
-define(POC_TIMEOUT, 10).
-endif.


%% ------------------------------------------------------------------
%% API exports
%% ------------------------------------------------------------------
-export([
    start_link/0,
    save_local_poc_keys/2,
    check_target/3,
    report/4,
    active_pocs/0,
    local_poc/1,
    local_poc_key/1,
    local_poc_keys/1
]).
%% ------------------------------------------------------------------
%% gen_server exports
%% ------------------------------------------------------------------
-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2]).

%% ------------------------------------------------------------------
%% record defs and macros
%% ------------------------------------------------------------------
-record(addr_hash_filter, {
    start :: pos_integer(),
    height :: pos_integer(),
    byte_size :: pos_integer(),
    salt :: binary(),
    bloom :: bloom_nif:bloom()
}).

-record(poc_local_key_data, {
    receive_height :: non_neg_integer(),
    keys :: keys(),
    onion_key_hash :: binary()
}).

-record(local_poc, {
    onion_key_hash :: binary(),
    block_hash :: binary() | undefined,
    keys :: keys() | undefined,
    target :: libp2p_crypto:pubkey_bin(),
    onion :: binary() | undefined,
    secret :: binary() | undefined,
    responses = #{} :: #{binary() => [{binary(), blockchain_poc_witness_v1:witness()}] | {binary(), blockchain_poc_receipt_v1:poc_receipt()}},
    challengees = [] :: [libp2p_crypto:pubkey_bin()],
    packet_hashes = [] :: [{libp2p_crypto:pubkey_bin(), binary()}],
    start_height :: non_neg_integer()
}).

-record(state, {
    db :: rocksdb:db_handle(),
    local_pocs_cf :: rocksdb:cf_handle(),
    local_poc_keys_cf :: rocksdb:cf_handle(),
    chain :: undefined | blockchain:blockchain(),
    ledger :: undefined | blockchain:ledger(),
    sig_fun :: undefined | libp2p_crypto:sig_fun(),
    pub_key = undefined :: undefined | libp2p_crypto:pubkey_bin(),
    addr_hash_filter :: undefined | #addr_hash_filter{}
}).
-type state() :: #state{}.
-type keys() :: #{secret => libp2p_crypto:privkey(), public => libp2p_crypto:pubkey()}.

-type local_poc() :: #local_poc{}.
-type local_pocs() :: [local_poc()].
-type local_poc_key() :: #poc_local_key_data{}.
-type local_poc_keys() :: [local_poc_key()].

-export_type([keys/0, local_poc_key/0, local_poc_keys/0, local_poc/0, local_pocs/0]).

%% ------------------------------------------------------------------
%% API functions
%% ------------------------------------------------------------------
-spec start_link() -> {ok, pid()}.
start_link() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).

-spec save_local_poc_keys(CurHeight :: non_neg_integer(), [keys()]) -> ok.
save_local_poc_keys(CurHeight, KeyList) ->
    %% these are the keys ( public & private ) generated by this validator
    %% as part of submitting a new heartbeat
    %% push each key set to rocks with a hash of the public key as key
    %% each new block we will then check if any of our keys made it into the block
    %% and if so retrieve the private key for each
    case persistent_term:get(?LOCAL_POC_KEYS_DB_CF, not_found) of
        not_found ->
            lager:warning("failed to save poc keys, no db"),
            ok;
        {DB, CF} ->
            [
                begin
                    #{public := PubKey} = Keys,
                    OnionKeyHash = crypto:hash(sha256, libp2p_crypto:pubkey_to_bin(PubKey)),
                    POCKeyRec = #poc_local_key_data{receive_height = CurHeight,
                        keys = Keys, onion_key_hash = OnionKeyHash},
                    lager:debug("saving local poc key ~p at height ~p", [OnionKeyHash, CurHeight]),
                    catch write_local_poc_keys(POCKeyRec, DB, CF)
                end
                || Keys <- KeyList
            ],
            ok
    end.

-spec active_pocs()->[local_poc()].
active_pocs() ->
    gen_server:call(?MODULE, {active_pocs}).

-spec check_target(
    Challengee :: libp2p_crypto:pubkey_bin(),
    BlockHash :: binary(),
    OnionKeyHash :: binary()
) -> false | {true, binary()} | {error, any()}.
check_target(Challengee, BlockHash, OnionKeyHash) ->
    PoCCache = persistent_term:get(poc_cache),
    LocalPOC = cream:cache(
                PoCCache,
                OnionKeyHash,
                fun() -> ?MODULE:local_poc(OnionKeyHash) end
    ),
    Res =
        case LocalPOC of
            {error, not_found} ->
                %% if the cache returns not found it could be the poc has not yet been initialized
                %% so check if we have a cached local POC key.
                %% These are added when a val HB is submitted by the local node
                %% if such a key exists its an indication the POC may not yet have been initialized
                %% OR the e2qc cache was called before the POC was initialised and it
                %% has cached the {error, not_found} term
                %% so if we have the key then check rocks again,
                %% if still not available then its likely the POC hasnt been initialized
                %% if found then invalidate the e2qc cache
                case ?MODULE:local_poc_key(OnionKeyHash) of
                    {ok, _LocalKey} ->
                        %% the submitted key is one of this nodes local keys
                        lager:debug(" ~p is a known key", [OnionKeyHash]),
                        case ?MODULE:local_poc(OnionKeyHash) of
                            {error, _} ->
                                %% clients should retry after a period of time
                                {error, <<"queued_poc">>};
                            {ok, #local_poc{block_hash = BlockHash, target = Challengee, onion = Onion}} ->
                                cream:evict(PoCCache, OnionKeyHash),
                                {true, Onion};
                            {ok, #local_poc{block_hash = BlockHash, target = _OtherTarget}} ->
                                cream:evict(PoCCache, OnionKeyHash),
                                false;
                            {ok, #local_poc{block_hash = _OtherBlockHash, target = _Target}} ->
                                cream:evict(PoCCache, OnionKeyHash),
                                {error, <<"mismatched_block_hash">>}
                        end;
                    _ ->
                        lager:debug("~p is NOT a known key", [OnionKeyHash]),
                        {error, <<"invalid_or_expired_poc">>}
                end;
            {ok, #local_poc{block_hash = BlockHash, target = Challengee, onion = Onion}} ->
                {true, Onion};
            {ok, #local_poc{block_hash = BlockHash, target = _OtherTarget}} ->
                false;
            {ok, #local_poc{block_hash = _OtherBlockHash, target = _Target}} ->
                {error, <<"mismatched_block_hash">>};
            _ ->
                false
        end,
    lager:info("*** check target result for gateway ~p and key ~p: ~p",
        [?TO_ANIMAL_NAME(Challengee), OnionKeyHash, Res]),
    Res.

-spec report(
    Report :: {witness, blockchain_poc_witness_v1:poc_witness()} | {receipt, blockchain_poc_receipt_v1:receipt()},
    OnionKeyHash :: binary(),
    Peer :: libp2p_crypto:pubkey_bin(),
    P2PAddr :: libp2p_crypto:peer_id()) -> ok.
report(Report, OnionKeyHash, Peer, P2PAddr) ->
    gen_server:cast(?MODULE, {Report, OnionKeyHash, Peer, P2PAddr}).

-spec local_poc(OnionKeyHash :: binary()) ->
    {ok, local_poc()} | {error, any()}.
local_poc(OnionKeyHash) ->
    case persistent_term:get(?LOCAL_POC_DB_CF, not_found) of
        not_found -> {error, not_found};
        {DB, CF} ->
            case rocksdb:get(DB, CF, OnionKeyHash, []) of
                {ok, Bin} ->
                    [POC] = erlang:binary_to_term(Bin),
                    {ok, upgrade_responses(POC)};
                not_found ->
                    {error, not_found};
                Error ->
                    lager:error("error: ~p", [Error]),
                    Error
            end
    end.

-spec local_poc_key(OnionKeyHash :: binary()) ->
    {ok, local_poc_key()} | {error, any()}.
local_poc_key(OnionKeyHash) ->
    case persistent_term:get(?LOCAL_POC_KEYS_DB_CF, not_found) of
        not_found -> {error, not_found};
        {DB, CF} ->
            case rocksdb:get(DB, CF, OnionKeyHash, []) of
                {ok, Bin} ->
                    [Key] = erlang:binary_to_term(Bin),
                    {ok, Key};
                not_found ->
                    {error, not_found};
                Error ->
                    lager:error("error: ~p", [Error]),
                    Error
            end
    end.

%% ------------------------------------------------------------------
%% gen_server functions
%% ------------------------------------------------------------------
init(_Args) ->
    lager:debug("starting ~p", [?MODULE]),
    erlang:send_after(500, self(), init),
    {ok, PubKey, SigFun, _ECDHFun} = blockchain_swarm:keys(),
    SelfPubKeyBin = libp2p_crypto:pubkey_to_bin(PubKey),
    {ok, {DB, LocalPoCsCF, LocalPoCKeysCF}} = miner_poc_mgr_db_owner:handles(),
    ok = persistent_term:put(?LOCAL_POC_DB_CF, {DB, LocalPoCsCF}),
    ok = persistent_term:put(?LOCAL_POC_KEYS_DB_CF, {DB, LocalPoCKeysCF}),
    {ok, #state{
        db = DB,
        local_pocs_cf = LocalPoCsCF,
        local_poc_keys_cf = LocalPoCKeysCF,
        sig_fun = SigFun,
        pub_key = SelfPubKeyBin
    }}.

handle_call({active_pocs}, _From, State = #state{}) ->
    {reply, local_pocs(State), State};
handle_call(_Request, _From, State = #state{}) ->
    {reply, ok, State}.

handle_cast({{witness, Witness}, OnionKeyHash, Peer, _PeerAddr}, State) ->
    handle_witness(Witness, OnionKeyHash, Peer, State);
handle_cast({{receipt, Receipt}, OnionKeyHash, Peer, PeerAddr}, State) ->
    handle_receipt(Receipt, OnionKeyHash, Peer, PeerAddr, State);
handle_cast(_Request, State) ->
    {noreply, State}.

handle_info(init, #state{chain = undefined} = State) ->
    %% No chain
    case blockchain_worker:blockchain() of
        undefined ->
            erlang:send_after(500, self(), init),
            {noreply, State};
        Chain ->
            ok = blockchain_event:add_handler(self()),
            ok = blockchain_poc_event:add_handler(self()),
            Ledger = blockchain:ledger(Chain),
            SelfPubKeyBin = blockchain_swarm:pubkey_bin(),
            {noreply, State#state{
                chain = Chain,
                ledger = Ledger,
                pub_key = SelfPubKeyBin
            }}
    end;
handle_info(init, State) ->
    {noreply, State};
handle_info({blockchain_event, {new_chain, NC}}, State) ->
    {noreply, State#state{chain = NC}};
handle_info({blockchain_event, _Event}, #state{chain = undefined} = State)->
    {noreply, State};
handle_info(
    {blockchain_event, {add_block, BlockHash, Sync, Ledger} = _Event},
    State
)->
    CurPOCChallengerType =
        case blockchain:config(?poc_challenger_type, Ledger) of
            {ok, V}  -> V;
            _ -> undefined
        end,
    lager:debug("received add block event, sync is ~p, poc_challenge_type is ~p", [Sync, CurPOCChallengerType]),
    State1 = maybe_init_addr_hash(Ledger, State),
    ok = handle_add_block_event(CurPOCChallengerType, BlockHash, Ledger, State1),
    {noreply, State1};
handle_info(
    {blockchain_poc_event, {poc_keys, {BlockHeight, BlockHash, BlockPOCs, Ledger}} = _Event},
    State
)->
    CurPOCChallengerType =
        case blockchain:config(?poc_challenger_type, Ledger) of
            {ok, V}  -> V;
            _ -> undefined
        end,
    State1 = maybe_init_addr_hash(Ledger, State),
    ok = process_block_pocs(CurPOCChallengerType, BlockHeight, BlockHash, BlockPOCs, Ledger, State1),
    {noreply, State1};
handle_info(_Info, State = #state{}) ->
    {noreply, State}.

terminate(_Reason, _State = #state{}) ->
    persistent_term:erase(?LOCAL_POC_DB_CF),
    persistent_term:erase(?LOCAL_POC_KEYS_DB_CF),
    ok.

%%%===================================================================
%%% breakout functions
%%%===================================================================
-spec handle_add_block_event(
    POCChallengeType :: validator | undefined,
    BlockHash :: binary(),
    Ledger :: blockchain:ledger(),
    State :: state()
) -> ok.
handle_add_block_event(POCChallengeType, BlockHash, Ledger, State) when POCChallengeType == validator ->
    case blockchain_ledger_v1:get_block(BlockHash, Ledger) of
        {ok, Block} ->
            BlockHeight = blockchain_block:height(Block),
            %% take care of GC
            ok = purge_local_pocs(Block, Ledger, State),

            %% GC local pocs keys based on the GC cadence window in blocks
            %% for the key propopsals in ledger v1; defaults to 101
            case BlockHeight rem blockchain_ledger_v1:poc_gc_interval(Ledger) == 0 of
                true ->
                    ok = purge_local_poc_keys(BlockHeight, Ledger, State);
                false ->
                    ok
            end;
        _ ->
            %% err what?
            ok
    end;
handle_add_block_event(_POCChallengeType, _BlockHash, _Ledger, _State) ->
    ok.

-spec handle_witness(
    Witness :: blockchain_poc_witness_v1:poc_witness(),
    OnionKeyHash :: binary(),
    Address :: libp2p_crypto:pubkey_bin(),
    State :: #state{}
) -> {noreply, state()}.
handle_witness(Witness, OnionKeyHash, Peer, #state{chain = Chain} = State) ->
    lager:debug("got witness ~p with onionkeyhash ~p", [Witness, OnionKeyHash]),
    GatewayWitness = blockchain_poc_witness_v1:gateway(Witness),
    case miner_poc_denylist:check(GatewayWitness) of
        true ->
            lager:notice("dropping witness from ~p due to denylist", [libp2p_crypto:bin_to_b58(GatewayWitness)]),
            {noreply, State};
        false ->
            %% Validate the witness is correct
            Ledger = blockchain:ledger(Chain),
            %% get the local POC
            case ?MODULE:local_poc(OnionKeyHash) of
                {error, _} ->
                    lager:warning("ignoring witness ~p for onionkeyhash ~p. Reason: no local_poc", [Witness, OnionKeyHash]),
                    {noreply, State};
                {ok, #local_poc{packet_hashes = PacketHashes, responses = Response0} = POC} ->
                    case validate_witness(Witness, Ledger) of
                        false ->
                            lager:warning("ignoring witness ~p for onionkeyhash ~p. Reason: invalid", [Witness, OnionKeyHash]),
                            {noreply, State};
                        true ->
                            PacketHash = blockchain_poc_witness_v1:packet_hash(Witness),
                            %% check this is a known layer of the packet
                            case lists:keyfind(PacketHash, 2, PacketHashes) of
                                false ->
                                    lager:warning("Saw invalid witness with packet hash ~p and onionkeyhash ~p", [PacketHash, OnionKeyHash]),
                                    {noreply, State};
                                {GatewayWitness, PacketHash} ->
                                    lager:warning("Saw self-witness from ~p for onionkeyhash ~p", [GatewayWitness, OnionKeyHash]),
                                    {noreply, State};
                                _ ->
                                    Witnesses = maps:get(PacketHash, Response0, []),
                                    %% Don't allow putting duplicate response in the witness list resp
                                    Predicate = fun({_, W}) -> blockchain_poc_witness_v1:gateway(W) == GatewayWitness end,
                                    Responses1 =
                                        case lists:any(Predicate, Witnesses) of
                                            false ->
                                                maps:put(PacketHash, lists:keystore(Peer, 1, Witnesses, {Peer, Witness}), Response0);
                                            true ->
                                                Response0
                                        end,
                                    UpdatedPOC = POC#local_poc{responses = Responses1},
                                    ok = write_local_poc(UpdatedPOC, State),
                                    {noreply, State}
                            end
                    end
            end
    end.

-spec handle_receipt(
    Receipt :: blockchain_poc_receipt_v1:receipt(),
    OnionKeyHash :: binary(),
    Peer :: libp2p_crypto:pubkey_bin(),
    PeerAddr :: libp2p_crypto:peer_id(),
    State :: #state{}
) -> {noreply, state()}.
handle_receipt(Receipt, OnionKeyHash, Peer, PeerAddr, #state{chain = Chain} = State) ->
    lager:info("got receipt ~p with onionkeyhash ~p", [Receipt, OnionKeyHash]),
    Gateway = blockchain_poc_receipt_v1:gateway(Receipt),
    LayerData = blockchain_poc_receipt_v1:data(Receipt),
    Ledger = blockchain:ledger(Chain),
    %% get the POC data from the cache
    case ?MODULE:local_poc(OnionKeyHash) of
        {error, _} ->
            lager:warning("ignoring receipt ~p for onionkeyhash ~p. Reason: no local_poc", [Receipt, OnionKeyHash]),
            {noreply, State};
        {ok, #local_poc{challengees = Challengees, responses = Response0} = POC} ->
            case blockchain_poc_receipt_v1:is_valid(Receipt, Ledger) of
                false ->
                    lager:warning("ignoring invalid receipt ~p for onionkeyhash", [Receipt, OnionKeyHash]),
                    {noreply, State};
                true ->
                    case lists:keyfind(Gateway, 1, Challengees) of
                        {Gateway, LayerData} ->
                            case maps:get(Gateway, Response0, undefined) of
                                undefined ->
                                    IsFirstChallengee =
                                        case hd(Challengees) of
                                            {Gateway, _} ->
                                                true;
                                            _ ->
                                                false
                                        end,
                                    %% compute address hash and compare to known ones
                                    case check_addr_hash(PeerAddr, State) of
                                        true when IsFirstChallengee ->
                                            %% drop whole challenge because we should always be able to get the first hop's receipt
                                            {noreply, State};
                                        true ->
                                            {noreply, State};
                                        undefined ->
                                            Responses1 = maps:put(
                                                Gateway,
                                                {Peer, Receipt},
                                                Response0
                                            ),
                                            UpdatedPOC = POC#local_poc{responses = Responses1},
                                            ok = write_local_poc(UpdatedPOC, State),
                                            {noreply, State};
                                        PeerHash ->
                                            Responses1 = maps:put(
                                                Gateway,
                                                {Peer,
                                                    blockchain_poc_receipt_v1:addr_hash(
                                                        Receipt,
                                                        PeerHash
                                                    )},
                                                Response0
                                            ),
                                            UpdatedPOC = POC#local_poc{responses = Responses1},
                                            ok = write_local_poc(UpdatedPOC, State),
                                            {noreply, State}
                                    end;
                                _ ->
                                    lager:warning("Already got this receipt ~p for ~p ignoring", [
                                        Receipt,
                                        Gateway
                                    ]),
                                    {noreply, State}
                            end;
                        {Gateway, OtherData} ->
                            lager:warning("Got incorrect layer data ~p from ~p (expected ~p) for onionkeyhash ~p", [
                                Gateway,
                                OtherData,
                                Receipt,
                                OnionKeyHash
                            ]),
                            {noreply, State};
                        false ->
                            lager:warning("Got unexpected receipt from ~p for onionkeyhash", [Gateway, OnionKeyHash]),
                            {noreply, State}
                    end
            end
    end.

%% ------------------------------------------------------------------
%% Internal functions
%% ------------------------------------------------------------------
initialize_poc(BlockHash, POCStartHeight, Keys, Vars, Ledger, #state{pub_key = Challenger} = State) ->
    #{public := OnionCompactKey, secret := {ecc_compact, POCPrivKey}} = Keys,
    POCPubKeyBin = libp2p_crypto:pubkey_to_bin(OnionCompactKey),
    #'ECPrivateKey'{privateKey = PrivKeyBin} = POCPrivKey,
    POCPrivKeyHash = crypto:hash(sha256, PrivKeyBin),
    OnionKeyHash = crypto:hash(sha256, POCPubKeyBin),
    Entropy = <<OnionKeyHash/binary, BlockHash/binary>>,
    ZoneRandState = blockchain_utils:rand_state(Entropy),
    InitTargetRandState = blockchain_utils:rand_state(POCPrivKeyHash),
    TargetMod = blockchain_utils:target_v_to_mod(blockchain:config(?poc_targeting_version, Ledger)),
    case TargetMod:target(Challenger, InitTargetRandState, ZoneRandState, Ledger, Vars) of
        {error, Reason}->
            lager:warning("failed to find a target for poc key ~p, reason ~p", [OnionKeyHash, Reason]),
            noop;
        {ok, {TargetPubkeybin, TargetRandState}}->
            case miner_poc_denylist:check(TargetPubkeybin) of
                true ->
                    lager:notice("cancelling challenge to ~p due to denylist", [libp2p_crypto:bin_to_b58(TargetPubkeybin)]),
                    noop;
                false ->
                    {ok, LastChallenge} = blockchain_ledger_v1:current_height(Ledger),
                    {ok, B} = blockchain_ledger_v1:get_block(LastChallenge, Ledger),
                    Time = blockchain_block:time(B),
                    BlockHeight = blockchain_block:height(B),
                    Path = blockchain_poc_path_v4:build(TargetPubkeybin, TargetRandState, Ledger, Time, Vars),
                    N = erlang:length(Path),
                    [<<IV:16/integer-unsigned-little, _/binary>> | LayerData] = blockchain_txn_poc_receipts_v2:create_secret_hash(
                        Entropy,
                        N + 1
                    ),
                    OnionList = lists:zip([libp2p_crypto:bin_to_pubkey(P) || P <- Path], LayerData),
                    {Onion, Layers} = blockchain_poc_packet_v2:build(Keys, IV, OnionList),
                    [_|LayerHashes] = [crypto:hash(sha256, L) || L <- Layers],
                    Challengees = lists:zip(Path, LayerData),
                    PacketHashes = lists:zip(Path, LayerHashes),
                    Secret = libp2p_crypto:keys_to_bin(Keys),
                    %% save the POC data to our local cache
                    LocalPOC = #local_poc{
                        onion_key_hash = OnionKeyHash,
                        block_hash = BlockHash,
                        target = TargetPubkeybin,
                        onion = Onion,
                        secret = Secret,
                        challengees = Challengees,
                        packet_hashes = PacketHashes,
                        keys = Keys,
                        start_height = POCStartHeight
                    },
                    ok = write_local_poc(LocalPOC, State),
                    lager:info("started poc at blockheight ~p for challengeraddr ~p, onionhash ~p, target: ~p",
                        [BlockHeight, ?TO_ANIMAL_NAME(Challenger), OnionKeyHash, ?TO_ANIMAL_NAME(TargetPubkeybin)]),
                    ok
            end
    end.

-spec process_block_pocs(
    POCChallengeType :: libp2p_crypto:pubkey_bin(),
    BlockHeight :: pos_integer(),
    BlockHash :: blockchain_block:hash(),
    BlockPOCs :: [{binary(), blockchain_ledger_poc_v3:poc()}],
    Ledger :: blockchain:ledger(),
    State :: state()
) -> ok.
process_block_pocs(
    POCChallengeType,
    BlockHeight,
    BlockHash,
    BlockPOCs,
    Ledger,
    State
)  when POCChallengeType == validator ->
    lager:debug("poc mgr block pocs: ~p", [BlockPOCs]),
    [
        begin
            OnionKeyHash = blockchain_ledger_poc_v3:onion_key_hash(POCV3),
            %% use onion key hash to check our local cache containing the keys of POCs owned by this validator
            %% if it is one of this local validators POCs, then kick it off
            case ?MODULE:local_poc_key(OnionKeyHash) of
                {ok, #poc_local_key_data{keys = Keys}} ->
                    %% its a locally owned POC key, so kick off a new POC
                    Vars = blockchain_utils:vars_binary_keys_to_atoms(
                        maps:from_list(blockchain_ledger_v1:snapshot_vars(Ledger))),
                    %% confirm the POC exists on the ledger, if not then drop the POC
                    case blockchain_ledger_v1:find_public_poc(OnionKeyHash, Ledger) of
                        {ok, PubPoC} ->
                            PoCBlockHash = blockchain_ledger_poc_v3:block_hash(PubPoC),
                            case BlockHash =:= PoCBlockHash of
                                true ->
                                    spawn(fun() -> initialize_poc(BlockHash, BlockHeight, Keys, Vars, Ledger, State) end);
                                false ->
                                    lager:warning("found a local poc key but mismatched blockhash: ~p ~p", [BlockHash, PoCBlockHash]),
                                    ok
                            end;
                        _ ->
                            lager:warning("found a local poc key but public data missing, onionkeyhash: ~p", [OnionKeyHash]),
                            ok
                    end;
                _ ->
                    noop
            end
        end
        || POCV3 <- BlockPOCs
    ],
    ok;
process_block_pocs(
    _POCChallengerType,
    _BlockHeight,
    _BlockHash,
    _BlockPOCs,
    _Ledger,
    _State
) ->
    ok.

-spec purge_local_pocs(
    Block :: blockchain_block:block(),
    Ledger :: blockchain_ledger_v1:ledger(),
    State :: state()
) -> ok.
purge_local_pocs(
    Block,
    Ledger,
    #state{pub_key = SelfPubKeyBin, sig_fun = SigFun} = State
) ->
    %% iterate over the local POCs in our rocksdb
    %% end and clean up any which have exceeded their life span
    %% these are active POCs which were initiated by this node
    %% and the data is known only to this node
    Timeout =
        case blockchain:config(?poc_timeout, Ledger) of
            {ok, N} -> N;
            _ -> ?POC_TIMEOUT
        end,
    BlockHeight = blockchain_block:height(Block),
    LocalPOCs = local_pocs(State),
    lists:foreach(
        fun([#local_poc{start_height = POCStartHeight, onion_key_hash = OnionKeyHash} = POC]) ->
            case (BlockHeight - POCStartHeight) > Timeout of
                true ->
                    lager:debug("*** purging local poc with key ~p", [OnionKeyHash]),
                    %% this POC's time is up, submit receipts we have received
                    ok = submit_receipts(POC, SelfPubKeyBin, SigFun, Ledger),
                    %% as receipts have been submitted, we can delete the local poc from the db
                    %% the public poc data will remain until at least the receipt txn is absorbed
                    _ = delete_local_poc(OnionKeyHash, State);
                _ ->
                    ok
            end
        end,
        LocalPOCs
    ),
    ok.

-spec purge_local_poc_keys(
    BlockHeight :: pos_integer(),
    Ledger :: blockchain_ledger_v1:ledger(),
    State :: state()
) -> ok.
purge_local_poc_keys(
    BlockHeight,
    Ledger,
    State = #state{local_poc_keys_cf = CF, db = DB}
) ->
    %% iterate over the poc keys in rocks
    %% and purge any which are deemed to be passed due
    %% these keys are generated by *this* node
    %% as part of its heartbeat submission
    %% and added to the rocks db
    %% each new block check if each mined key
    %% for that block is one of our own
    %% if it is then we initiate a new local POC
    %% the keys are purged periodically
    POCTimeout =
        case blockchain:config(?poc_timeout, Ledger) of
            {ok, N} -> N;
            _ -> ?POC_TIMEOUT
        end,
    {ok, POCEphemeralKeyTimeout} = blockchain:config(?poc_validator_ephemeral_key_timeout, Ledger),
    {ok, HBInterval} = blockchain:config(?validator_liveness_interval, Ledger),
    {ok, HBGracePeriod} = blockchain:config(?validator_liveness_grace_period, Ledger),
    %% iterate over the cached POC keys, delete any which are beyond the lifespan of when the active POC would have ended
    CachedPOCKeys = local_poc_keys(State),
    lists:foreach(
        fun([#poc_local_key_data{receive_height = ReceiveHeight, onion_key_hash = Key}]) ->
            case BlockHeight > (ReceiveHeight + POCEphemeralKeyTimeout + POCTimeout + HBInterval + HBGracePeriod) of
                true ->
                    %% the lifespan of any POC for this key has passed, we can GC
                    lager:debug("GCing local poc key ~p, blockheight: ~p, receive height: ~p",
                        [Key, BlockHeight, ReceiveHeight]),
                    ok = delete_local_poc_keys(Key, DB, CF);
                _ ->
                    ok
            end
        end,
        CachedPOCKeys
    ),
    ok.

-spec submit_receipts(local_poc(), libp2p_crypto:pubkey_bin(),
    libp2p_crypto:sig_fun(), blockchain_ledger_v1:ledger()) -> ok.
submit_receipts(
    #local_poc{
        onion_key_hash = OnionKeyHash,
        responses = Responses0,
        secret = Secret,
        packet_hashes = LayerHashes,
        block_hash = BlockHash,
        target = Target
    } = _Data,
    Challenger,
    SigFun,
    Ledger
) ->
    case maps:size(Responses0) of
        0 ->
            lager:info("POC timed out with no responses for key ~p & target ~p", [OnionKeyHash, ?TO_ANIMAL_NAME(Target)]),
            ok;
        _ ->
            PerHopMaxWitnesses = blockchain_utils:poc_per_hop_max_witnesses(Ledger),
            Path1 = lists:foldl(
                fun({Challengee, LayerHash}, Acc) ->
                    {Address, Receipt} = maps:get(Challengee, Responses0, {make_ref(), undefined}),
                    %% get any witnesses not from the same p2p address and also ignore challengee as a witness (self-witness)
                    Witnesses = [W || {A, W} <- maps:get(LayerHash, Responses0, []), A /= Address, A /= Challengee],
                    %% randomize the ordering of the witness list
                    Witnesses1 = blockchain_utils:shuffle(Witnesses),
                    %% take only the limit
                    Witnesses2 = lists:sublist(Witnesses1, PerHopMaxWitnesses),
                    E = blockchain_poc_path_element_v1:new(Challengee, Receipt, Witnesses2),
                    [E | Acc]
                end,
                [],
                LayerHashes
            ),
            Txn0 =
                case blockchain:config(?poc_version, Ledger) of
                    {ok, PoCVersion} when PoCVersion >= 10 ->
                        blockchain_txn_poc_receipts_v2:new(
                            Challenger,
                            Secret,
                            OnionKeyHash,
                            lists:reverse(Path1),
                            BlockHash
                        );
                    _ ->
                        %% hmm we shouldnt really hit here as this all started with poc version 10
                        noop
                end,
            lager:info("submitting blockchain_txn_poc_receipts_v2. challenger: ~p, target: ~p, onionkeyhash ~p: txn: ~p", [?TO_ANIMAL_NAME(Challenger), ?TO_ANIMAL_NAME(Target), OnionKeyHash, Txn0]),
            Txn1 = blockchain_txn:sign(Txn0, SigFun),
            ok = blockchain_txn_mgr:submit(Txn1, fun(_Result) -> noop end)
    end.

-spec validate_witness(blockchain_poc_witness_v1:witness(), blockchain_ledger_v1:ledger()) ->
    boolean().
validate_witness(Witness, Ledger) ->
    %% TODO this should be against the ledger at the time the receipt was mined
    case blockchain_poc_witness_v1:frequency(Witness) of
        0.0 ->
            %% Witnesses with 0.0 frequency are considered invalid
            false;
        _ ->
            Gateway = blockchain_poc_witness_v1:gateway(Witness),
            case blockchain_ledger_v1:find_gateway_info(Gateway, Ledger) of
                {error, _Reason} ->
                    lager:warning("failed to get witness ~p info ~p", [Gateway, _Reason]),
                    false;
                {ok, GwInfo} ->
                    case blockchain_ledger_gateway_v2:location(GwInfo) of
                        undefined ->
                            lager:warning("ignoring witness ~p location undefined", [Gateway]),
                            false;
                        _ ->
                            blockchain_poc_witness_v1:is_valid(Witness, Ledger)
                    end
            end
    end.

check_addr_hash(_PeerAddr, #state{addr_hash_filter = undefined}) ->
    undefined;
check_addr_hash(PeerAddr, #state{
    addr_hash_filter = #addr_hash_filter{byte_size = Size, salt = Hash, bloom = Bloom}
}) ->
    case multiaddr:protocols(PeerAddr) of
        [{"ip4", Address}, {_, _}] ->
            {ok, Addr} = inet:parse_ipv4_address(Address),
            Val = binary:part(
                enacl:pwhash(
                    list_to_binary(tuple_to_list(Addr)),
                    binary:part(Hash, {0, enacl:pwhash_SALTBYTES()})
                ),
                {0, Size}
            ),
            case bloom:check_and_set(Bloom, Val) of
                true ->
                    true;
                false ->
                    Val
            end;
        _ ->
            undefined
    end.

-spec maybe_init_addr_hash(blockchain_ledger_v1:ledger(), #state{}) -> #state{}.
maybe_init_addr_hash(_Ledger, #state{chain = undefined} = State) ->
    %% no chain
    State;
maybe_init_addr_hash(Ledger, #state{chain = Chain, addr_hash_filter=undefined} = State) ->
    %% check if we have the block we need
    case blockchain:config(?poc_addr_hash_byte_count, Ledger) of
        {ok, Bytes} when is_integer(Bytes), Bytes > 0 ->
            case blockchain:config(?poc_challenge_interval, Ledger) of
                {ok, Interval} ->
                    {ok, Height} = blockchain_ledger_v1:current_height(Ledger),
                    StartHeight = max(Height - (Height rem Interval), 1),
                    %% check if we have this block
                    case blockchain_ledger_v1:get_block(StartHeight, Ledger) of
                        {ok, Block} ->
                            Hash = blockchain_block:hash_block(Block),
                            %% ok, now we can build the filter
                            Gateways = blockchain_ledger_v1:gateway_count(Ledger),
                            %% on new networks, this count is 0 which causes
                            %% the nif to crash, or at least for the return
                            %% value to not match the ok tuple
                            %%
                            %% so we will take 1000 or the actual gateway
                            %% count, whichever is larger.
                            {ok, Bloom} = bloom:new_optimal(max(1000, Gateways), ?ADDR_HASH_FP_RATE),
                            sync_filter(Block, Bloom, Chain),
                            State#state{
                                addr_hash_filter = #addr_hash_filter{
                                    start = StartHeight,
                                    height = Height,
                                    byte_size = Bytes,
                                    salt = Hash,
                                    bloom = Bloom
                                }
                            };
                        _ ->
                            State
                    end;
                _ ->
                    State
            end;
        _ ->
            State
    end;
maybe_init_addr_hash(
    Ledger,
    #state{
        chain = Chain,
        addr_hash_filter = #addr_hash_filter{
            start = StartHeight,
            height = Height,
            byte_size = Bytes,
            salt = Hash,
            bloom = Bloom
        }
    } = State
) ->
    case blockchain:config(?poc_addr_hash_byte_count, Ledger) of
        {ok, Bytes} when is_integer(Bytes), Bytes > 0 ->
            case blockchain:config(?poc_challenge_interval, Ledger) of
                {ok, Interval} ->
                    {ok, CurHeight} = blockchain_ledger_v1:current_height(Ledger),
                    case max(Height - (Height rem Interval), 1) of
                        StartHeight ->
                            case CurHeight of
                                Height ->
                                    %% ok, everything lines up
                                    State;
                                _ ->
                                    case blockchain_ledger_v1:get_block(Height + 1, Ledger) of
                                        {ok, Block} ->
                                            sync_filter(Block, Bloom, Chain),
                                            State#state{
                                                addr_hash_filter = #addr_hash_filter{
                                                    start = StartHeight,
                                                    height = CurHeight,
                                                    byte_size = Bytes,
                                                    salt = Hash,
                                                    bloom = Bloom
                                                }
                                            };
                                        _ ->
                                            State
                                    end
                            end;
                        _NewStart ->
                            %% filter is stale
                            maybe_init_addr_hash(Ledger, State#state{addr_hash_filter = undefined})
                    end;
                _ ->
                    State
            end;
        _ ->
            State#state{addr_hash_filter = undefined}
    end.

sync_filter(StopBlock, Bloom, Blockchain) ->
    blockchain:fold_chain(
        fun(Blk, _) ->
            blockchain_utils:find_txn(Blk, fun(T) ->
                case blockchain_txn:type(T) == blockchain_txn_poc_receipts_v2 of
                    true ->
                        %% abuse side effects here for PERFORMANCE
                        [update_addr_hash(Bloom, E) || E <- blockchain_txn_poc_receipts_v2:path(T)];
                    false ->
                        ok
                end,
                false
            end),
            case Blk == StopBlock of
                true ->
                    return;
                false ->
                    continue
            end
        end,
        any,
        element(2, blockchain:head_block(Blockchain)),
        Blockchain
    ).

-spec update_addr_hash(
    Bloom :: bloom_nif:bloom(),
    Element :: blockchain_poc_path_element_v1:poc_element()
) -> ok.
update_addr_hash(Bloom, Element) ->
    case blockchain_poc_path_element_v1:receipt(Element) of
        undefined ->
            ok;
        Receipt ->
            case blockchain_poc_receipt_v1:addr_hash(Receipt) of
                undefined ->
                    ok;
                Hash ->
                    bloom:set(Bloom, Hash)
            end
    end.

upgrade_responses(POCs) when is_list(POCs) ->
    [ upgrade_responses(POC) || POC <- POCs ];
upgrade_responses(#local_poc{responses=Responses}=POC) ->
    NewResponses = maps:map(fun(_Key, Value) when is_list(Value) ->
                                    %% witnesses are stored in a key/value list
                                    lists:map(fun({Key, Witness}) ->
                                                      {Key, blockchain_poc_witness_v1:maybe_upgrade(Witness)}
                                              end, Value);
                               (_Key, {Peer, Value}) when element(1, Value) == blockchain_poc_receipt_v1_pb ->
                               {Peer, blockchain_poc_receipt_v1:maybe_upgrade(Value)}
                            end, Responses),
    POC#local_poc{responses=NewResponses}.

%% ------------------------------------------------------------------
%% DB functions
%% ------------------------------------------------------------------
local_pocs(#state{db=DB, local_pocs_cf=CF}) ->
    {ok, Itr} = rocksdb:iterator(DB, CF, []),
    local_pocs(Itr, rocksdb:iterator_move(Itr, first), []).

local_pocs(Itr, {error, invalid_iterator}, Acc) ->
    catch rocksdb:iterator_close(Itr),
    Acc;
local_pocs(Itr, {ok, _, LocalPOCBin}, Acc) ->
    local_pocs(Itr, rocksdb:iterator_move(Itr, next), [upgrade_responses(binary_to_term(LocalPOCBin))|Acc]).

local_poc_keys(#state{db=DB, local_poc_keys_cf=CF}) ->
    {ok, Itr} = rocksdb:iterator(DB, CF, []),
    local_poc_keys(Itr, rocksdb:iterator_move(Itr, first), []).

local_poc_keys(Itr, {error, invalid_iterator}, Acc) ->
    catch rocksdb:iterator_close(Itr),
    Acc;
local_poc_keys(Itr, {ok, _, LocalPOCKeyBin}, Acc) ->
    local_poc_keys(Itr, rocksdb:iterator_move(Itr, next), [binary_to_term(LocalPOCKeyBin)|Acc]).

-spec write_local_poc(  LocalPOC ::local_poc(),
                        State :: state()) -> ok.
write_local_poc(#local_poc{onion_key_hash=OnionKeyHash} = LocalPOC, #state{db=DB, local_pocs_cf=CF}) ->
    ToInsert = erlang:term_to_binary([LocalPOC]),
    rocksdb:put(DB, CF, OnionKeyHash, ToInsert, []).

-spec delete_local_poc( OnionKeyHash ::binary(),
                        State :: state()) -> ok.
delete_local_poc(OnionKeyHash, #state{db=DB, local_pocs_cf=CF}) ->
    rocksdb:delete(DB, CF, OnionKeyHash, []).

-spec write_local_poc_keys( KeySet ::local_poc_key(),
                            DB :: rocksdb:db_handle(),
                            CF :: rocksdb:cf_handle()) -> ok.
write_local_poc_keys(LocalPOCKey = #poc_local_key_data{onion_key_hash = OnionKeyHash}, DB, CF) ->
    ToInsert = erlang:term_to_binary([LocalPOCKey]),
    rocksdb:put(DB, CF, OnionKeyHash, ToInsert, []).

-spec delete_local_poc_keys( OnionKeyHash ::binary(),
                             DB :: rocksdb:db_handle(),
                             CF :: rocksdb:cf_handle()) -> ok.
delete_local_poc_keys(OnionKeyHash, DB, CF) ->
    rocksdb:delete(DB, CF, OnionKeyHash, []).

-ifdef(TEST).

upgrade_responses_test() ->
    Responses = #{<<"challengee">> => {<<"peer">>, {blockchain_poc_receipt_v1_pb,<<"r">>,10,10,<<"data">>,p2p,<<>>,
                              1.2,915.2,2,<<"dr">>,<<>>,0}},
                  <<"packethash">> => [{<<"2">>, {blockchain_poc_witness_v1_pb,<<"w1">>,10,10,<<"ph">>,<<>>,1.2,
                              915.2,2,<<"dr">>}},
                               %% the following should not need upgrading
                              {<<"3">>, {blockchain_poc_witness_v1_pb,<<"w2">>,10,10,<<"ph">>,<<>>,1.2,
                              915.2,2,<<"dr">>, 1.0}}]},
    Upgraded = upgrade_responses(#local_poc{responses=Responses}),
    lists:all(fun(E) when element(1, E) == blockchain_poc_witness_v1_pb ->
                      blockchain_poc_witness_v1:print(E),
                      true
              end, element(2, lists:unzip(lists:flatten(maps:get(<<"packethash">>, Upgraded#local_poc.responses))))),
    blockchain_poc_receipt_v1:print(element(2, maps:get(<<"challengee">>, Upgraded#local_poc.responses))),

    ?assertError(function_clause, lists:all(fun(E) when element(1, E) == blockchain_poc_witness_v1_pb ->
                      blockchain_poc_witness_v1:print(E),
                      true
              end, element(2, lists:unzip(lists:flatten(maps:get(<<"packethash">>, Responses)))))),
    ?assertError(function_clause, blockchain_poc_receipt_v1:print(element(2, maps:get(<<"challengee">>, Responses)))),
    ok.

-endif.
